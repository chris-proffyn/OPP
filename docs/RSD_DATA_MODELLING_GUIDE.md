# Proffyn Rapid Solution Delivery (RSD)
## Data Modelling Guide

**Document Type:** Foundational Data Modelling & Database Governance  
**Applies To:** All Proffyn RSD Projects  
**Audience:** Cursor, Proffyn Delivery Team  
**Status:** v1.0 (Baseline)

---

## 0. Document Control

This document is a **foundational RSD artefact**.

It defines how data models, database schemas, and access rules must be designed and implemented across all Proffyn Rapid Solution Delivery projects.

- Generic and reusable across all projects
- Non-product-specific
- Mandatory reference when designing or modifying data models
- Closely aligned with Supabase and Row Level Security (RLS)

---

## 1. Purpose of This Document

This guide defines the **standard data modelling approach** for all RSD projects.

It exists to:
- Ensure data consistency, integrity, and security
- Enable rapid delivery without schema chaos
- Provide clear guidance for Supabase-based modelling
- Prevent accidental data leakage or privilege escalation
- Give Cursor explicit guardrails when working with the database

---

## 2. Core Data Modelling Principles

### 2.1 Database as Source of Truth
- Postgres is the authoritative data store
- Business invariants must be enforceable at the database level
- Application code must not be the sole guardian of data integrity

---

### 2.2 Explicit Is Better Than Implicit
- Columns must be explicit and intentional
- Avoid overloading fields with multiple meanings
- Prefer clarity over compactness

---

### 2.3 Predictability Over Cleverness
- Simple schemas are preferred
- Avoid polymorphic or highly dynamic structures unless justified
- Schema evolution should be incremental and understandable

---

### 2.4 Security by Default
- All user-facing tables must have RLS enabled
- Access rules are enforced in the database, not just in code
- Default posture is deny, then explicitly allow

---

## 3. Supabase & Postgres Assumptions

Unless explicitly overridden, all RSD projects assume:

- Supabase-managed Postgres
- UUID primary keys
- Timestamp fields using `timestamptz`
- RLS enabled on all relevant tables
- Supabase Auth (`auth.uid()`) as the identity source

---

## 4. Table Design Standards

### 4.1 Primary Keys

- Use UUIDs for all primary keys
- Generated by the database where possible
- Never expose sequential IDs publicly

Example:
- `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`

---

### 4.2 Timestamp Fields

All tables should include:
- `created_at timestamptz DEFAULT now()`
- `updated_at timestamptz DEFAULT now()`

Rules:
- `created_at` is immutable
- `updated_at` must be maintained via trigger

---

### 4.3 Ownership & Identity Columns

Where data is user-owned, include:
- `owner_id` or `user_id` referencing the profile or auth user
- Ownership must be enforceable via RLS

---

### 4.4 Naming Conventions

- Tables: plural, snake_case (e.g. `group_members`)
- Columns: snake_case
- Foreign keys: `{referenced_table}_id`
- Avoid abbreviations unless universally understood

---

## 5. Relationships & Foreign Keys

### 5.1 Referential Integrity

- All relationships must be enforced with foreign keys
- `ON DELETE` behaviour must be explicit:
  - `CASCADE`
  - `SET NULL`
  - `RESTRICT`

Implicit relationships are not acceptable.

---

### 5.2 Join Tables

Use join tables for:
- Many-to-many relationships
- Membership or role-based relationships

Join tables should:
- Have composite or surrogate primary keys
- Include timestamps
- Include role/status fields where relevant

---

## 6. Row Level Security (RLS)

### 6.1 Mandatory Use

- RLS must be enabled on all user-facing tables
- RLS is the primary authorisation mechanism
- Client-side filtering is not a security control

---

### 6.2 Common RLS Patterns

Typical patterns include:
- Ownership-based access
- Role-based access
- Membership-based access
- Tenant or organisation scoping

Policies must be:
- Readable
- Named clearly
- Documented inline

---

### 6.3 Testing RLS

- Both allowed and denied paths must be tested
- RLS failures are security defects
- RLS logic must not rely on application code

---

## 7. Soft Deletes & Lifecycle Management

### 7.1 Soft Delete Strategy

Where deletion should be reversible or auditable:
- Use a `deleted_at timestamptz` column
- Exclude soft-deleted rows via RLS or views

Hard deletes are acceptable where:
- Data is truly ephemeral
- No audit requirement exists

---

### 7.2 Status Fields

Use explicit status fields where lifecycle matters:
- `status` enums or constrained text
- Avoid encoding status implicitly

---

## 8. Auditability & History

Where appropriate, models should support:
- Change tracking
- Creator attribution
- Basic audit trails

Common approaches:
- `created_by`
- `updated_by`
- Append-only history tables (where justified)

Auditability should be intentional, not accidental.

---

## 9. Indexing & Performance

### 9.1 Indexing Principles

- Index foreign keys
- Index commonly filtered fields
- Avoid speculative indexing

Indexes should be:
- Added intentionally
- Reviewed when query patterns change

---

### 9.2 Performance Trade-offs

- Favour correctness over premature optimisation
- Measure before optimising
- Do not denormalise without evidence

---

## 10. Migrations & Schema Evolution

### 10.1 Migration Discipline

- All schema changes must be via migrations
- Migrations must be versioned and reviewed
- Never edit schemas manually in production

---

### 10.2 Backward Compatibility

- Consider existing data when evolving schemas
- Avoid destructive changes without mitigation
- Data migrations must be explicit

---

## 11. Data Access via Application Code

- All database access goes through a data-access layer
- Application code must not bypass RLS
- Service-role keys must never be used client-side

---

## 12. Anti-Patterns (Avoid)

- JSON blobs for core relational data
- Overloaded columns
- Implicit permissions
- Dynamic schema generation
- Disabling RLS for convenience

---

## 13. Summary

This Data Modelling Guide ensures that RSD projects have data layers that are:

- Secure
- Predictable
- Maintainable
- Scalable
- Easy to reason about

It exists to protect both users and developers as systems grow.

Deviation is allowed only when **explicit, justified, and documented**.
